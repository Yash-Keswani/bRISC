{
  "add": [
    {
      "opcode": "0b00000",
      "semantics": "Stores <R2> + <R3> in <R1>",
      "notes": "May set the overflow flag. Upper limit is 65536",
      "syntax": "ADD <R1> <R2> <R3>",
      "type": "A"
    }
  ],
  "sub": [
    {
      "opcode": "0b00001",
      "semantics": "Stores <R2> - <R3> in <R1>.",
      "notes": "May set the overflow flag. Lower Limit is 0",
      "syntax": "SUB <R1> <R2> <R3>",
      "type": "A"
    }
  ],
  "mov": [
    {
      "opcode": "0b00010",
      "semantics": "Copies the value of $<Imm> into <R1>.",
      "notes": "<Imm> must be an 8-bit value.",
      "syntax": "MOV <R1> $<Imm>",
      "type": "B"
    },
    {
      "opcode": "0b00011",
      "semantics": "Copies the value of <R2> into <R1>.",
      "notes": "Special-use registers can be read from, but not written into.",
      "syntax": "MOV <R1> <R2>",
      "type": "C"
    }
  ],
  "ld": [
    {
      "opcode": "0b00100",
      "semantics": "Loads the value from memory address <ADDR> to <R1>.",
      "notes": "Memory address has a cap of 512. Avoid messing with instructions in the memory.",
      "syntax": "LD <R1> <ADDR>",
      "type": "D"
    }
  ],
  "st": [
    {
      "opcode": "0b00101",
      "semantics": "Stores the value in <R1> at the memory address <ADDR>.",
      "notes": "Memory address has a cap of 512. Avoid messing with instructions in the memory.",
      "syntax": "ST <R1> <ADDR>",
      "type": "D"
    }
  ],
  "mul": [
    {
      "opcode": "0b00110",
      "semantics": "Stores <R2> * <R3> in R1.",
      "notes": "May set the overflow flag. Upper limit if 65536.",
      "syntax": "MUL <R1> <R2> <R3>",
      "type": "A"
    }
  ],
  "div": [
    {
      "opcode": "0b00111",
      "semantics": "Performs R3 / R4. Stores the quotient in R0 and the remainder in R1. ",
      "syntax": "div reg3 reg4",
      "type": "C"
    }
  ],
  "rs": [
    {
      "opcode": "0b01000",
      "semantics": "Right shifts reg1 by $Imm, where $Imm is an 8 bit value. ",
      "syntax": "rs reg1 $Imm",
      "type": "B"
    }
  ],
  "ls": [
    {
      "opcode": "0b01001",
      "semantics": "Left shifts reg1 by $Imm, where $Imm is an 8 bit value. ",
      "syntax": "ls reg1 $Imm",
      "type": "B"
    }
  ],
  "xor": [
    {
      "opcode": "0b01010",
      "semantics": "Performs bitwise XOR of reg2 and reg3. Stores the result in reg1. ",
      "syntax": "xor reg1 reg2 reg3",
      "type": "A"
    }
  ],
  "or": [
    {
      "opcode": "0b01011",
      "semantics": "Performs bitwise OR of reg2 and reg3. Stores the result in reg1. ",
      "syntax": "or reg1 reg2 reg3",
      "type": "A"
    }
  ],
  "and": [
    {
      "opcode": "0b01100",
      "semantics": "Performs bitwise AND of reg2 and reg3. Stores the result in reg1. ",
      "syntax": "and reg1 reg2 reg3",
      "type": "A"
    }
  ],
  "not": [
    {
      "opcode": "0b01101",
      "semantics": "Performs bitwise NOT of reg2. Stores the result in reg1. ",
      "syntax": "not reg1 reg2 ",
      "type": "C"
    }
  ],
  "cmp": [
    {
      "opcode": "0b01110",
      "semantics": "Compares reg1 and reg2 and sets up the FLAGS register.",
      "syntax": "cmp reg1 reg2 ",
      "type": "C"
    }
  ],
  "jmp": [
    {
      "opcode": "0b01111",
      "semantics": "Jumps to mem_addr where mem_addr is a memory address",
      "syntax": "jmp mem_addr ",
      "type": "E"
    }
  ],
  "jlt": [
    {
      "opcode": "0b10000",
      "semantics": "Jumps to mem_addr if the leass than flag is set (less than flag=1), where mem_addr is a memory address",
      "syntax": "jlt mem_addr ",
      "type": "E"
    }
  ],
  "jgt": [
    {
      "opcode": "0b10001",
      "semantics": "Jumps to <address> if greater-than is present in the FLAGS register.",
      "syntax": "jgt <address>",
      "type": "E"
    }
  ],
  "je": [
    {
      "opcode": "0b10010",
      "semantics": "Jumps to <address> if equality is present in the FLAGS register.",
      "notes": "",
      "syntax": "je <address>",
      "type": "E"
    }
  ],
  "hlt": [
    {
      "opcode": "0b10011",
      "semantics": "Stops the execution of the code.",
      "notes": "Any lines after this instruction will not be read. Can only be present at the end of a program [blank lines excluded]",
      "syntax": "hlt",
      "type": "F"
    }
  ]
}